#!/usr/bin/env perl
use strict;
use warnings;
use v5.10;

=head1 SYNOPSIS

To run all tests, simply execute this script.  

To list tests, specify "--list"

To run a specific test case, specify "--test NUM"

See the script source for additional configuration parameters and details on defined test configurations.

=head1 Dependencies

The default configuration of this script requires that NM is built with "--enable-nmrest".  Alternate execution via the Automator interface is possible, but has been disabled due to unresolved timing issues related to log file flushing.

The following dependencies should be installed via cpan/cpanm:

  JSON REST::Client Expect File::Slurp

Note: Net::HTTP dependenceis of REST::Client may need to be manually installed with "-f" flag in some systems.


=cut

use Term::ANSIColor qw(:constants);
local $Term::ANSIColor::AUTORESET = 1;

use Cwd;
use Getopt::Long;
use File::Compare; # for validating file-based tests
use Pod::Usage;
use JSON;
use REST::Client;

use Data::Dumper; # For debug/tracing

require "./test.pm";

my $time_display_text = 0;
my $time_wait_finish  = 5;
my $verbose = 0;
my $test_prompt = 0;

my $do_startup = 1; # Execute startup of ION. If disabled, assume ION is already running
my $do_shutdown = 1; # Cleanly shutdown ION on completion. If disabled, attempt to leave ION running.
my $fail_prompt = 0;
my $exit_on_fail = 0;
my $run_single_test;
my ($help, $man);
my $list_tests = 0;
my ($mgr, $agent3, $agent4);
my $rest_host = "http://localhost";
my $rest_port = 8089;
my $log_file = "tests.log";
my $spawn_mode = "screen";
my $spawn_term = "xterm";
my $assume_clean_startup = 0;
my $log_dir = File::Spec->catdir(getcwd(), "logs"); # Directory to consolidate log files generated by this script (excludes ion.log files)
my $use_old_cbor = 0; # To aide testing of prior NM AMP specifications during development

# Agent EID Configurations
my $mgr_eid = "ipn:2.65";
my $agent1_eid = "ipn:3.64";
my $agent2_eid = "ipn:4.64";

# SQL Support
my $dbhost = "db";
my $dbuser = "amp";
my $dbpass = "amp";
my $db     = "amp_core";
my $use_db = 0;

Getopt::Long::GetOptions(
    "help"            => \$help,
    "man"             => \$man,
    "display_time=i"  => \$time_display_text,
    "wait_time=i"     => \$time_wait_finish,
    "abort!"          => \$exit_on_fail,
    "test=i"          => \$run_single_test,
    "verbose!"        => \$verbose,
    "prompt|break!"   => \$test_prompt,
    "break-on-error!" => \$fail_prompt,
    "list!"           => \$list_tests,
    "host=s"          => \$rest_host,
    "port=s"          => \$rest_port,
    "log=s"           => \$log_file,
    "startup!"        => \$do_startup,
    "shutdown!"       => \$do_shutdown,
    "skip_init_clean!"=> \$assume_clean_startup,
    "log_dir=s"       => \$log_dir,

    "term=s"          => \$spawn_term,
    "mode=s"          => \$spawn_mode,
    "old!"            => \$use_old_cbor,
    "db!"             => \$use_db,
    "sql-host=s"      => \$dbhost,
    "sql-user=s"      => \$dbuser,
    "sql-pass=s"      => \$dbpass,
    "sql-db=s"        => \$db,
    );
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;

# Create Test Driver Object
my $td = ION::Test->new(
    verbose => $verbose,
    time_display_text => $time_display_text,
    time_wait_finish => $time_wait_finish,
    test_prompt => $test_prompt,
    prompt_on_fail => $fail_prompt,
    exit_on_fail => $exit_on_fail,
    log_file => $log_file,
    # TODO:  tests => \@tests
    spawn_mode => $spawn_mode,
    spawn_term => $spawn_term,
    skip_initial_cleanup => $assume_clean_startup,
    log_dir => $log_dir,
    beforeEach => \&beforeEach,
    );

# Setup REST Client
my $client = REST::Client->new();
my $uri = $rest_host;
$uri .= ":$rest_port" if $rest_port;
$client->setHost($uri);

# Common Test Configuration Elements
my $check_bp_agent_rpt = {
                 "num_entries" => 43,
                 "report_name" => "full_report",
                 "entries" => {
                     "name" => "bp_agent",
                     }
                };
my $check_amp_agent_rpt = {
                 "num_entries" => 16,
                 "report_name" => "full_report",
                 "entries" => {
                     "name" => "amp_agent",
                     }
                };
my $check_num_tbl_tpls = {
    "num_entries" => 1,
    "report_name" => "num_tbl_tpls",
    #"entries" =>  20, # Value may change with ADM definitions and is irrelevant for verification in this case.
   };
my $check_num_rules_var = {
    "num_entries" => 1,
    "report_name" => "num_rules",
    "entries" =>  0,
   };


# Test Configuration Definition
my @tests = (
    # 0: Base Case sending a bundle to verify connectivity as a sanity check
    ["Send Bundle to verify test configuration", sub {$td->full_test(@_); } ],

    # Start Old amp_agent_suite.txt
    ["Generate Agent ADM Full Report", \&adm_report_test,
     {
         "comment" => "Old Step 1.1,1.2",
         "description" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])",

         "cbor"     => "0xc11541050502252381871819410000",
         "cbor_old" => "0xc11541054f840542252347814587181941004180",
         "reports" => [ $check_amp_agent_rpt ],

     }],
    
    
    ["Generate BP Agent Full Reports", \&adm_report_test,
     {
         "comment" => "Old Step 1.3, 1.4",
         "description" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/DTN:bp.agent/Rptt.full_report()],[])",

         "cbor"     => "0xc1154105050225238187182d410000",
         "cbor_old" => "c11541054f840542252347814587182d41004180",
         "reports" => [ $check_bp_agent_rpt ],
     }],

    ["Generate ADM Report and BP Report Concurrently", \&adm_report_test,
     {
         "comment" => "Old Step 1.5, 1.6",
         "description" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report(),ari:/DTN:bp.agent/Rptt.full_report()],[]",

         "cbor"     => "0xc11541050502252382871819410087182d410000",
         "cbor_old" => "0xc11541055584054225234d824587181941004587182d41004180",

         "num_reports" => 2,
         "reports" => [ $check_bp_agent_rpt, $check_amp_agent_rpt ],
        }],

    ["Generate Endpoint report for invalid endpoint ipn:1.1", \&adm_report_test,
     {
         "comment" => "Based on Old Steps 2.x",
         "description" => " ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/DTN:bp.agent/Rptt.endpoint_report(\"ipn:1.1\")],[]) ",
         
         "cbor"     => "0xc11541050502252381c7182d41010501126769706e3a312e3100",
         "cbor_old" => "c1154105581d8405422523558153c7182d41014d83054112486769706e3a312e314180",
         "reports" => [
             {
                 "num_entries" => 0,

                 # Check report_name and arguments (concatenated into a string in orginal text report)
                 "report_name" => "endpoint_report",
                 "arguments" => ["ipn:1.1"],
                }
            ],
     }],

    ["Generate Endpoint report for endpoint ipn:3.64", \&adm_report_test,
     {
         "comment" => "Based on Old Steps 2.x",
         "description" => " ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/DTN:bp.agent/Rptt.endpoint_report(\"ipn:3.64\")],[]) ",
         
         "cbor"     => "0xc11541050502252381c7182d41010501126869706e3a332e363400",
         "cbor_old" => "0xc1154105581e8405422523568154c7182d41014e83054112496869706e3a332e36344180",
         "reports" => [
             {
                 "num_entries" => 3,
                 "report_name" => "endpoint_report",
                 "arguments" => ["ipn:3.64"],
                }
            ],
     }],
    ["Generate Endpoint report for endpoints ipn:1.1,ipn:3.64,ipn:3.65", \&adm_report_test,
     {
         "comment" => "Based on Old Steps 2.x",
         "description" => " ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/DTN:bp.agent/Rptt.endpoint_report(\"ipn:1.1\",\"ipn:3.64\",\"ipn:3.65\")],[])",
         
         "cbor"     => "0xc11541050502252383c7182d41010501126769706e3a312e31c7182d41010501126869706e3a332e3634c7182d41010501126869706e3a332e363500",
         "cbor_old" => "0xc115410558488405422523583f8353c7182d41014d83054112486769706e3a312e3154c7182d41014e83054112496869706e3a332e363454c7182d41014e83054112496869706e3a332e36354180",
         "num_reports" => 3,
         "reports" => [
             {
                 "num_entries" => 3,
                 "report_name" => "endpoint_report",
                 "arguments" => ["ipn:3.64"],
             },
             {
                 "num_entries" => 3,
                 "name" => "endpoint_report",
                 "arguments" => ["ipn:3.65"],
             },
             {
                 "num_entries" => 0,
                 "report_name" => "endpoint_report",
                 "arguments" => ["ipn:1.1"],
             }
            ],
     }],
    
    ["Generate Report for NUM_TBL_TPLS EDD", \&adm_report_test,
     {
         "comment" => "Old step 3.1",
         "description" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Edd.num_tbl_tpls()],[])",
         
         "cbor"     => "c115410505022523818216410100",
         "cbor_old" => "c11541054e8405422523468144821641014180",
         "reports" => [$check_num_tbl_tpls],
     }],
    ["Generate Report for NUM_RULES VAR", \&adm_report_test,
     {
         "comment" => "Old step 3.3",
         "description" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Var.num_rules()],[])",
         
         "cbor"     => "c115410505022523818c181d410000",
         "cbor_old" => "c11541054f84054225234781458c181d41004180",
         "reports" => [$check_num_rules_var],
     }],
    ["Generate Report for NUM_RULES VAR & NUM_TBL_TPLS EDD", \&adm_report_test,
     {
         "comment" => "Old step 3.5",
         "description" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Edd.num_tbl_tpls(),ari:/IANA:amp.agent/Var.num_rules()],[])",
         
         "cbor"     => "c11541050502252382821641018c181d410000",
         "cbor_old" => "c11541055484054225234c824482164101458c181d41004180",
         "num_reports" => 2,
         "reports" => [$check_num_rules_var, $check_num_tbl_tpls],
     }],

    
    ["Report Template Validation", \&report_template_test,
     {
         "comment" => "This is a multi-step test sequence reflecting original test case 4",
         "description" => "Test creation, usage, and deletion of a report template",

         "cbor" => {
             "add_rptt" => "0xc115410205022425a7014101410182821641018c181d4100",
             "describe"  => "0xc115410405012581a70141014101",
             "dump_rptt" => "0xc115410605022523818a181b410200",
             "get_r1"    => "0xc11541050502252381a7014101410100",
             "delete_r1" => "0xc115410305012581a70141014101",
         },
         "cbor_old" => { # AMPv6 taken from amp_agent_suite.txt
             "add_rptt" => "c11541025818840542242545a7014101014c824482164101458c181d4100",
             "describe" => "c11541044c83054125478145a701410101",
             "dump_rptt"=> "c11541064f84054225234781458a181b41024180",
             "get_r1"   => "c11541054f8405422523478145a7014101014180",
             "delete_r1"=> "c11541034c83054125478145a701410101",
         },
         "uri" => {
             "add_rptt"  => "ari:/IANA:amp.agent/Ctrl.add_rptt(ari:/:/RPTTPL.,[ari:/IANA:amp.agent/Edd.num_tbl_tpls(),ari:/IANA:amp.agent/Var.num_rules()])",
             "describe"  => "ari:/IANA:amp.agent/Ctrl.desc_rptt([ari:/:/RPTTPL.])",
             "dump_rptt" => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts()],[])",
             "get_r1"    => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts()],[])",
             "delete_r1" => "ari:/IANA:amp.agent/Ctrl.del_rptt([ari:/:/RPTTPL.])",
            }
        }],
    ["Describe the AMP Agent Full Report", \&adm_report_test,
     {
         "comment" => "Describes an AMP Agent Full Report.  Old step 5.1",
         "description" => "ari:/IANA:amp.agent/Ctrl.desc_rptt([ari:/IANA:amp.agent/Rptt.full_report()])",
         "num_reports" => 1,

         "cbor"     => "0xc1154104050125818718194100",
         "cbor_old" => "c11541044c830541254781458718194100",
         # Verification TODO
         #"reports" => [$check_num_tbl_tpls],
     }],
    ["Test Simple Variable Operations", \&variable_simple_ops_test,
     {
         "comment" => "This is a multi-step test sequence reflecting original 'TC1'",
         "description" => "Test creation, usage, and deletion of a variable",

         "cbor" => {
             "define_v1" => "0xc115410005032426118c18644101148343024302c5181841010014",
             "list_vars" => "0xc115410605022523818a181b410100",
             "report_v1" => "0xc115410505022523818c1864410100",
             "delete_v1" => "0xc1154101050125818c18644101",
         },
         "cbor_old" => { # AMPv6 taken from amp_agent_suite.txt
             "define_v1" => "c11541005820850543242611458c186441015150148342430242430247c51818410141804114",
             "list_vars" => "c11541064f84054225234781458a181b41014180",
             "report_v1" => "c11541054f84054225234781458c186441014180",
             "delete_v1" => "c11541014c830541254781458c18644101",
         },
         "uri" => {
             "define_v1" => "ari:/IANA:amp.agent/Ctrl.add_var(ari:/IANA:bpadmin/Const.ADM_OBJ_TYPE_CONST=Const-ERROR-UNIMPLEMENTED(),(20)[UINT.2,UINT.2,ari:/IANA:amp.agent/Oper.plusUINT([])],BYTE.20)",
             "list_vars" => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])",
             "report_v1" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:bpadmin/Const.ADM_OBJ_TYPE_CONST=Const-ERROR-UNIMPLEMENTED()],[])",
             "delete_v1" => "ari:/IANA:amp.agent/Ctrl.del_var([ari:/IANA:bpadmin/Const.ADM_OBJ_TYPE_CONST=Const-ERROR-UNIMPLEMENTED()])",
            }
        }],
    ["Test Complex Variable Operations", \&complex_variables_test,
     {
         "comment" => "This is a multi-step test sequence reflecting original 'TC2.2 for Complex Variables'",
         "description" => "Test creation, usage, and reporting of multiple variables and variable expressions.",

         "cbor" => {
             "define_v2" => "0xc11541000503242611ac01410241011481430414",
             "define_v3" => "0xc11541000503242611ac01410341011483ac01410241014301c5181841010026",
             "define_v4" => "0xc11541000503242611ac01410441011481ac014103410114",
             "define_r1" => "0xc115410205022425a7014105410183ac0141024101ac0141034101ac0141044101",
             "list_vars" => "0xc115410605022523818a181b410100",
             "generate_r1" => "0xc11541050502252381a7014105410100",
             "store_v2v4" => "0xc115410e05022426ac01410241011481ac0141044101",
             "store_v4v3" => "0xc115410e05022426ac01410441011481ac0141034101",
         },
         "cbor_old" => { # AMPv6 taken from amp_agent_suite.txt
             "define_v2" => "c11541005585054324261145ac01410201464514814243044114", # V2=4
             "define_v3" => "c1154100582385054324261145ac014103015453148345ac0141020142430147c51818410141804126", # V3=V2+1
             "define_v4" => "c1154100581885054324261145ac014104014948148145ac014103014114", # V4 = V3
             "define_r1" => "c1154102581f840542242545a701410501538345ac0141020145ac0141030145ac01410401", # R1 = V2,V3,V4
             "list_vars" => "c11541064f84054225234781458a181b41014180",
             "generate_r1" => "c11541054f8405422523478145a7014105014180", # Generate Report R1
             
             "store_v2v4" => "c115410e55840542242645ac014102014948148145ac01410401", # V2=V4
             "store_v4v3" => "c115410e55840542242645ac014104014948148145ac01410301", # V4=expr_eval(V3)
         },
         "uri" => { # Note: to-uri generation code for these controls are incomplete
             "define_v2" => "ari:/IANA:amp.agent/Ctrl.add_var(ari:/:/VAR.,(20)[UINT.4],BYTE.20)",
             "define_v3" => "ari:/IANA:amp.agent/Ctrl.add_var(ari:/:/VAR.,(20)[ari:/:/VAR.,UINT.1,ari:/IANA:amp.agent/Oper.plusUINT([])],BYTE.38)",
             "define_v4" => "ari:/IANA:amp.agent/Ctrl.add_var(ari:/:/VAR.,(20)[ari:/:/VAR.],BYTE.20)",
             "define_r1" => "ari:/IANA:amp.agent/Ctrl.add_rptt(ari:/:/RPTTPL.,[ari:/:/VAR.,ari:/:/VAR.,ari:/:/VAR.])",
             "list_vars" => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])",
             "generate_r1" => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/:/RPTTPL.],[])",
             "store_v2v4" => "ari:/IANA:amp.agent/Ctrl.store_var(ari:/:/VAR.,(20)[ari:/:/VAR.])",
             "store_v4v3" => "ari:/IANA:amp.agent/Ctrl.store_var(ari:/:/VAR.,(20)[ari:/:/VAR.])",
            }
        }],
    ["Macro Test", \&macros_test,
     {
         "description" => "Test Macro creation, list, execution, and deletion.",
         "comment" => "Create a macro that dumps an AMP full Report, Clears the AMP REport, produces new report. Test and verify macro.",
        "cbor" => {
             "create" => "0xc11541070503122425624d31a4014101410183c115410505022523818718194100008115410fc11541050502252381871819410000",
             "describe" => "0xc115410905012581a40141014101",
             "list" => "0xc115410605022523818a181b410300",
             "delete" => "0xc115410805012581a40141014101",
            },
         "cbor_old" => {
             "create" => "c1154107584285054312242543624d3145a40141010158308354c11541054f840542252347814587181941004180448115410f54c11541054f840542252347814587181941004180",
             "describe" => "c11541094c83054125478145a401410101",
             "list" => "c11541064f84054225234781458a181b41034180",
             "delete" => "c11541084c83054125478145a401410101",
         },
        "uri" => {
             "create" => "ari:/IANA:amp.agent/Ctrl.add_macro('M1',ari:/:/MAC.,[ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[]),ari:/IANA:amp.agent/Ctrl.reset_counts(),ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])])",
             "describe" => "ari:/IANA:amp.agent/Ctrl.desc_macro([ari:/:/MAC.])",
             "list" => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])",
             "delete" => "ari:/IANA:amp.agent/Ctrl.del_macro([ari:/:/MAC.])",
            },
     }],
    ["Time Based Rule Test (simple)", \&tbr_base_test,
     {
         "description" => "Time-Based Rule Validation (Original Test Set 3.1)",
         "comment" => "This test causes an AGENT FULL reprot to be generates 5x at 5s intervals and validates the timing.",
         "cbor_old" => "c115410a583588054624161616251245ab01410101410041054105568154c11541054f840542252347814587181941004180486747656e52707473",
         "cbor" => "0xc115410a0506241616162512ab014101410100050581c115410505022523818718194100006747656e52707473",
         "uri" => "ari:/IANA:amp.agent/Ctrl.add_tbr(ari:/:/TBR.,UVAST.0,UVAST.5,UVAST.5,[ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])],'GenRpts')",
     }],
    ["Time Based Rule Test", \&tbr_mod_test,
     {
         "description" => "Time-Based Rule Modification Test (Original Test Set 3.2)",
         "cbor_old" => {
             "define"   => "c115410a583488054624161616251245ab01410201410042181e421864568154c11541054f840542252347814587181941004180456454425232",
             "list"     => "c11541064f84054225234781458a181b41044180",
             "describe" => "c115410d4c83054125478145ab01410201",
             "delete"   => "c115410c4c83054125478145ab01410201",
            },
         "cbor" => {
             "define"   => "0xc115410a0506241616162512ab014102410100181e186481c115410505022523818718194100006454425232",
             "list"     => "0xc115410605022523818a181b410400",
             "describe" => "0xc115410d05012581ab0141024101",
             "delete"   => "0xc115410c05012581ab0141024101",
            },
         "uri" => {
             "define"   => "ari:/IANA:amp.agent/Ctrl.add_tbr(ari:/:/TBR.,UVAST.0,UVAST.30,UVAST.100,[ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])],'TBR2')",
             "list"     => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])",
             "describe" => "ari:/IANA:amp.agent/Ctrl.desc_rule([ari:/:/TBR.])",
             "delete"   => "ari:/IANA:amp.agent/Ctrl.del_rule([ari:/:/TBR.])",
            },
     }],
     ["Generate reports based on a variable", \&gen_var_report_test,
      {
          "description" => "Define a variable and report on it.",
          "cbor_old" => {
              "define_v5"   => "c11541005585054324261145ac01410501464514814243004114",
              "define_m1"   => "c115410758418505431224254463746d7045a401410501582e8254c11541054f84054225234781458718194100418057c115410e52840542242645ac0141050146451481424300",
              "define_srl"  => "c115410b583a8905472416261616251245a80141010141005554148345ac0141050142430248c5181842182f4180431903e84103478145a40141050143625331",
              "define_tbr"  => "c115410a584488054624161616251245ab014105014100411441065829815826c115410e5820840542242645ac014105015453148345ac0141050142430147c518184101418043625435",
              "delete_srl"  => "c115410c4c83054125478145a801410101",
              "retrieve"    => "c11541054f8405422523478145ac014105014180",
              "list_macros" => "c11541064f84054225234781458a181b41034180",
              "list_rules"  => "c11541064f84054225234781458a181b41044180",
              "describe_m1" => "c11541094c83054125478145a401410501",
              "describe_srl"=> "c115410d4c83054125478145a801410101",
              "describe_tbr"=> "c115410d4c83054125478145ab01410501",
          },
          "cbor" => {
              "define_v5"   => "0xc11541000503242611ac01410541011481430014",
              "define_m1"   => "0xc1154107050312242563746d70a4014105410182c11541050502252381871819410000c115410e05022426ac014105410114814300",
              "define_srl"  => "0xc115410b050724162616162512a80141014101001483ac01410541014302c5181842182f001903e80381a40141054101625331",
              "define_tbr"  => "0xc115410a0506241616162512ab014105410100140681c115410e05022426ac01410541011483ac01410541014301c51818410100625435",
              "delete_srl"  => "0xc115410c05012581a80141014101",
              "retrieve"    => "0xc11541050502252381ac014105410100",
              "list_macros" => "0xc115410605022523818a181b410300",
              "list_rules"  => "0xc115410605022523818a181b410400",
              "describe_m1" => "0xc115410905012581a40141054101",
              "describe_srl"=> "0xc115410d05012581a80141014101",
              "describe_tbr"=> "0xc115410d05012581ab0141054101",
             },
          "uri" => {
              "define_v5"   => "ari:/IANA:amp.agent/Ctrl.add_var(ari:/:/VAR.,(20)[UINT.0],BYTE.20)",
              "define_m1"   => 'ari:/IANA:amp.agent/Ctrl.add_macro("tmp",ari:/:/MAC.,[ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[]),ari:/IANA:amp.agent/Ctrl.store_var(ari:/:/VAR.,(20)[UINT.0])])',
              "define_srl"  => 'ari:/IANA:amp.agent/Ctrl.add_sbr(ari:/:/SBR.,UVAST.0,(20)[ari:/:/VAR.,UINT.2,ari:/IANA:amp.agent/Oper.-ERROR-ADM_OBJ_TYPE_OPER/6191-of-53-not-found([])],UVAST.1000,UVAST.3,[ari:/:/MAC.],"S1")',
              "define_tbr"  => 'ari:/IANA:amp.agent/Ctrl.add_tbr(ari:/:/TBR.,UVAST.0,UVAST.20,UVAST.6,[ari:/IANA:amp.agent/Ctrl.store_var(ari:/:/VAR.,(20)[ari:/:/VAR.,UINT.1,ari:/IANA:amp.agent/Oper.plusUINT([])])],"T5")',
              "delete_srl"  => "ari:/IANA:amp.agent/Ctrl.del_rule([ari:/:/SBR.])",
              "retrieve"    => "ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/:/VAR.],[])",
              "list_macros" => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])",
              "list_rules"  => "ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])",
              "describe_m1" => "ari:/IANA:amp.agent/Ctrl.desc_macro([ari:/:/MAC.])",
              "describe_srl"=> "ari:/IANA:amp.agent/Ctrl.desc_rule([ari:/:/SBR.])",
              "describe_tbr"=> "ari:/IANA:amp.agent/Ctrl.desc_rule([ari:/:/TBR.])",           
             },
      }],
    #End old amp_agent_suite.txt
    
    ["ari:/IANA:Amp.Agent/Ctrl.gen_rpts([ari:/IANA:DTN.bpsec/Rptt.source_report(ipn:1.1)],[])",
     \&adm_report_test,
     {
         "cbor" => "0xc11541050502252381c7185541010501126769706e3a312e3100",
         "cbor_old" => "0xc11541054f840542252347814587181941004180",
        }],

    # ari:/IANA:DTN.bp_agent/CTRL.reset_all_counts()",
    # "ari:0x8118294100",

    ["ari:/IANA:Amp.agent/CTRL.gen_rpts([ari:/ADM:dtn.bp_agent/rptt.full_report],[])",
     \&adm_report_test,
     {
         cbor => "0xc11541050502252381374b66756c6c5f7265706f72744341444d4c64746e2e62705f6167656e7400",
     }],

    ["ari:/IANA:Amp.Agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/rptt.endpoint_report(\"ipn:1.1\"), ari:/IANA:dtn.bp_agent/rptt.endpoint_report(\"ipn:1.2\")], [])",
     \&adm_report_test,
     {
         num_reports => 2,
         cbor =>"0xc11541050502252382c7182d4101050112692269706e3a312e3122c7182d4101050112692269706e3a312e322200",
     }],

    ["ari:/IANA:Amp.Agent/Ctrl.add_tbr(ari:/test:/TBR.t1, 0, 10, 20, [ari:/IANA:amp.agent/ctrl.gen_rpts([ari:/IANA:DTN.bp_agent/rptt.full_report],[])], TBR1)",
     \&adm_report_test,
     {
         disabled => "TODO: Cleanup after TBR",
         cbor => "0xc115410a05062420201625122b4274314474657374000a1481c1154105050225238187182d4100006454425231",
     }],
    
    ["ari:/IANA:Amp.Agent/Ctrl.add_sbr(ari:/test:/SBR.s1, 0, (BOOL)[ari:/test:/VAR.y, UINT.4, ari:/IANA/Amp.Agent/Op.greaterEqual], 20, 10, [ari:/IANA:amp.agent/ctrl.gen_rpts([ari:/IANA:DTN.bp_agent/rptt.full_report],[])], STR.SBR1)",
     \&adm_report_test,
     {
         disabled => "TODO: This message doesn't generate a report. How to verify?",
         cbor => "0xc115410b0507242026161625122842733144746573740010832c417944746573744304851818412f140A81c1154105050225238187182D4100006453425231",
     }],

    );


# TODO: Move this into object?
if ($list_tests) {
    $td->list_tests(\@tests);
    exit;
}

if ($do_startup) {
    # Cleanup any prior tests & startup base agents
    $td->global_startup();
    
    # And startup programs specific to this test file
    local_startup();
}



    
# Run tests
if (defined($run_single_test)) {
    die ("Invalid test number ($run_single_test)") unless defined($tests[$run_single_test]);
    $td->run_tests(\@tests, $run_single_test);
    
} else {
    $td->run_tests(\@tests);
}


# Cleanup
if ($do_shutdown) {
    say GREEN "Shutting down . . . ";

    $mgr->stop() if $mgr;
    $agent3->stop() if $agent3;
    $agent4->stop() if $agent4;

    $td->global_shutdown();
} else {
    say YELLOW "Shutdown sequence bypassed";
}

# Show results and exit where return code is the number of tests that failed.
exit $td->show_results();

sub adm_report_test
{
    my $idx = shift; # Test Number for logging purposes
    my $opts = shift;
    my $rtv = 1;
    
    my $agent = $agent3; # TODO: Get from opts (perhaps idx becomes an idx into local set of agents)
    my $cbor_hex = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};
    my $wait_time = $opts->{wait_time} // $time_wait_finish;
    my $expected_num_reports = $opts->{num_reports} // 1; # Must be at least 1

    if (!defined($cbor_hex)) {
        say RED "Invalid test ($idx): HEX-Encoded CBOR ARI is required, skipping.";
        return 0;
    }

    # Verify clean starting point
    if (verify_all_reports_cleared() != 0) {
        say RED "Pre-test checks failed; Unable to query reports, or reports list not cleared by previous test.";
        return -1;
    }

    # Send Command
    $mgr->send_ari($agent, $cbor_hex);

    # Retrieve & validate reports
    my $reports = $mgr->wait_reports($agent, $expected_num_reports, $time_wait_finish, "json");
    if (!defined($reports)) {
        say RED "ERROR: Failed to find expected number of reports for ".$agent->{eid};
        return -1;
    }
    
    if (!defined($reports->{reports})) {
        say RED "ERROR Retrieving reports";
        $rtv = -1;
    } else {
        my $num_reports = scalar(@{$reports->{reports}});
        my @cnts = (0) x $num_reports; # Match counts per definition index
        for(my $i = $num_reports-1; $i >= 0; $i--) {
            my $rpt = $reports->{reports}[$i];
            say Dumper($rpt) if $verbose;
            $rtv = validate_report_obj($rpt, $opts, $i, \@cnts);
            last if $rtv < 0;
        }

        # And validate expected counts per report type, if validations are defined
        if (defined($opts->{reports})) {
            my $total_cnt = 0;
            for(my $i = $num_reports-1; $i >= 0; $i--) {
                my $rpt = $reports->{reports}[$i];
                my $expected = $rpt->{expected_occurrences} // 1;
                if ($expected < 0) {
                    next; # A value of -1 means do not check occurrence count
                }
                if ($expected != $cnts[$i]) {
                    say RED "Saw a configured report definition ".$cnts[$i]." times, but expected $expected";
                    $rtv = -1;
                }
                $total_cnt += $cnts[$i];
            }
            if ($total_cnt != $num_reports) {
                say RED "Received $num_reports, but validated $total_cnt";
                $rtv = -1;
            }
        }
    }

    

    if ($test_prompt) {
        say "Press enter to proceed with test cleanup";
        my $tmp = <STDIN>;
    }

    # Cleanup
    verify_all_reports_cleared();

    # Done
    return $rtv;
}
sub validate_report_obj
{
    my $rpt = shift;
    my $opts = shift; # Generla Test Options
    my $idx = shift; # Index of report in list. May be used for validation in some tests
    my $cnts = shift; # To validate report counts
    my $rtv = 1;

    my $entries = $rpt->{entries};

    # Basic Sanity Checks
    if (!defined($entries)) {
        say RED "Got a report with no entries!";
        return -1;
    }

    my $num_entries = (ref($entries) eq "HASH") ? scalar(keys %$entries) : scalar(keys @$entries);
    if ($rpt->{num_entries} != $num_entries) {
        say RED "Report is inconsistent.  num_entries $rpt->{num_entries} does not match number of entries retrieved ($num_entries)";
        return -1;
    }

    if (defined($opts->{reports})) {
        my $found = 0;
        
        # Get Per-Report Options.  Assume order may not be fixed
        for (my $i = scalar(@{$opts->{reports}})-1; $i >= 0; $i--) {
            my $ropts = $opts->{reports}[$i];

            # Validate number of entries
            next if ($ropts->{num_entries} && $rpt->{num_entries} != $ropts->{num_entries});

            # Validate Name of Report
            next if ($ropts->{report_name} && $rpt->{name} ne $ropts->{report_name});

            # Check arguments
            if (defined($ropts->{arguments})) {
                next unless (defined($rpt->{arguments}) && $rpt->{arguments} ~~ $ropts->{arguments});
            }

            # Validate type (ie: HASH, SCALAR, or ARRAY)
            my $type = ref($ropts->{entries});

            if (defined($ropts->{entries_type})) {
                next unless $type eq $ropts->{entries_type};
            }
            
            # Validate entries
            if (defined($ropts->{entries})) {

                # Validate content
                if ($type eq "HASH") {
                    say "DEBUG: Validating hash report";
                    next unless validate_report_obj_entries_obj($ropts->{entries}, $rpt->{entries});
                } else {
                    say "DEBUG: Validating scalar/array report";
                    next unless validate_report_obj_entries($ropts->{entries}, $rpt->{entries});
                }
            }

            $found = 1;
            @$cnts[$i]++;

            last;
        }
        $rtv = -1 unless $found;
    } else {
        # Validate expected num entries
        my $exp_num_entries = $opts->{num_entries};
        if (defined($exp_num_entries) && $exp_num_entries != $rpt->{num_entries}) {
            say RED "Expected $opts->{num_entries} entries in report, saw $rpt->{num_entries}";
            $rtv = -1;
        }

        # No additional validation defined
        # Use reports array if additional details are to be defined.
    }

    
    return $rtv;
}

# Validate a Report Object (Hash, compared to array or scalar) inside a list of reports
sub validate_report_obj_entries_obj
{
    my $cfg_entries = shift;
    my $entries = shift;

    my $failed = 0;
    foreach my $key (keys %$cfg_entries ) {
        if (!defined($entries->{$key})) {
            say "DEBUG: $entries->{$key} not defined";
            $failed = 1;
            last;
        } elsif ($entries->{$key} ne $cfg_entries->{$key}) {
            $failed = 1;
            say "DEBUG: $entries->{$key} ne $cfg_entries->{$key}";
            last;
        }
    }
    return !$failed;
}
sub validate_report_obj_entries
{
    my $cfg_entries = shift;
    my $entries = shift;

    if (ref($entries) eq "ARRAY") {
        if (ref($cfg_entries) eq "ARRAY") {
            # Comparing two arrays

            # Validate lengths are equal
            return 0 unless scalar(@{$cfg_entries}) == scalar(@$entries);

            for (my $i = 0; $i < scalar(@$entries); $i++) {
                # TODO: Consider regex or other advanced comparison options in future
                return 0 unless @$entries[$i] eq @$cfg_entries[$i];
            }
        } else {
            # Comparing a scalar to an array.
            # Assume that entries is an array of a single element, possibly with a nested single element array

            # Array must contain a single element
            return 0 unless scalar(@$entries) == 1;

            my $tmp = @$entries[0];
            if (ref($tmp) eq "ARRAY") {
                return 0 unless scalar(@$tmp) == 1;
                $tmp = @$tmp[0];
            }
            return 0 unless $tmp eq $cfg_entries;
        }
    } else {
        if (ref($cfg_entries) ) {
            die "ERROR: Bad validation configuraiton";
        } else {
            # Simple scalar comparison
            return $cfg_entries eq $entries;
        }
    }
}

# Return 0 if all report cnts cleared, otherwise count of agents for which report clear commands issued
sub verify_all_reports_cleared
{
    my $data = $mgr->get_agents();
    my $rtv = 0;

    return -1 unless ref($data) eq "HASH";

    my $agents = $data->{agents};

    for (my $i = 0; $i < @$agents; $i++)
    {
        my $agent = @$agents[$i];

        if ($agent->{rpts_count} != 0) {
            $mgr->clear_reports($agent->{name});
            $rtv++;
        }
    }
    return $rtv;
}

sub get_report_row_count {
    my $rpt = shift;
    my $table = $rpt->{table};
    my $row = $table->{rows};
    return scalar(@$row);
}

sub do_rest_query {
    my $method = shift; # ie: GET, POST, PUT
    my $uri = shift; # Can be path, ie: "/nm/api/agents"
    my $data = shift;

    $client->$method($uri, $data);
    
    my $rtv = $client->responseCode();
    #say "Return code $rtv.  Data: ".$client->responseContent();

    if ($rtv >= 200 && $rtv < 300) {
        if ($client->responseHeader("Content-Type") =~ /json/) {
            $rtv = decode_json($client->responseContent());
        } else {
            # Return Text Response, or empty string if no data but still successful
            $rtv = $client->responseContent() // "";
        }
    } else {
        $rtv = undef;
    }

    $td->log(JSON->new()->canonical([1])->encode({
                 method => $method,
                 uri    => $uri,
                 result => $rtv,
                 data   => $data
             }));

    return $rtv;
}

sub local_startup
{
    $mgr = Manager->new(eid => $mgr_eid,
                        dir => File::Spec->catdir(getcwd(), "2.ipn.ltp"),
                        mode => ($spawn_mode eq "expect") ? "expect" : "rest",
                        "db" => $use_db, dbhost => $dbhost, dbuser => $dbuser, dbpass => $dbpass, db => $db
                       );
    $mgr->start();
    
    # And node 3 receivers
    chdir("3.ipn.ltp");
    system("bpsink ipn:3.1 > 3_results.txt &");
    system("bprecvfile ipn:3.2 &");
    $agent3 = Agent->new($agent1_eid);
    $agent3->start();
    chdir("..");
    
    # And node 4 receivers (for 3-node tests)
    chdir("4.ipn.ltp");
    system("bpsink ipn:4.1 > 4_results.txt &");
    system("bprecvfile ipn:4.2 &");
    $agent4 = Agent->new($agent2_eid);
    $agent4->start();
    chdir("..");

    say YELLOW "Waiting 1 for startup";
    sleep(1); # Wait for ION to finish startup

}
sub restart_mgr
{
    $td->log("Restarting nm_mgr");

    # Stop it
    #$td->stop_cmd($mgr);
    $mgr->stop();
    sleep(1); # Git it time to shutdown gracefully
    
    # Verify MGR has stopped
    my $agents = $mgr->is_alive();
    if (defined($agents)) {
        # If we were able to query the mgr, it didn't shutdown
        say RED "Unable to shutdown manager";
        return 0;
    }

    # Restart it
    $mgr->start();
    
    # Wait for MGR to restart
    for(my $i = 0; $i < 10; $i++) {
        $agents = $mgr->is_alive();
        last if (defined($agents));
        sleep(1);
    }
    if (!defined($agents)) {
        say RED "Unable to restart manager";
        return 0;
    }
    
    # Re-register agents with mgr
    $mgr->register_agent($agent1_eid);
    $mgr->register_agent($agent2_eid);
    
    # Verify agents have been re-registered
    $agents = $mgr->get_agents();

    # Verify we are back to where we started
    if (!defined($agents) || scalar(@{$agents->{agents}}) != 2) {
        say RED "Failed to re-register agents with mgr";
        say Dumper($agents); # DEBUG
    }

    
    $td->log("nm_mgr restart completed");
    return 1;
}

# Called before each test is run
sub beforeEach
{
    verify_all_reports_cleared();
    # TODO: Clear Tables as well (currently no tests defining)
}

sub fail_clear # TODO: Use this throughout
{
    my $msg = shift;
    say RED $msg if $msg;
    #verify_all_reports_cleared(); # TODO: Flag to skip this to aide debugging. 
    return -1;
}

sub report_template_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3; # TODO: Get from opts
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};

    # Verify clean starting point
    if (verify_all_reports_cleared() != 0) {
        say RED "Pre-test checks failed; Unable to query reports, or reports list not cleared by previous test.";
        return -1;
    }

    my $verify_added = sub {
        my $msg = shift;
        my $mode = shift // 0;  # If 1, check for deletion instead

        # Describe the Report
        $mgr->send_ari($agent, $cbor->{"describe"}) || return fail_clear("describe failed");

        # Dump TBLTT
        $mgr->send_ari($agent, $cbor->{"dump_rptt"}) || return fail_clear("dump failed");

        # Get Report
        $mgr->send_ari($agent, $cbor->{"get_r1"}) || return fail_clear("get_r1 failed");

        # Get Reports
        my $reports = $mgr->wait_reports($agent, 3, undef, "json");
        return fail_clear("ERROR: Failed to find expected number of reports $msg") if (!defined($reports));
        
        # Verify Describe
        my $desc = @{$reports->{reports}}[0];
        my $entries = $desc->{entries};
        my $args = $desc->{arguments};

        return fail_clear("desc_rptt has bad name $msg") unless $desc->{name} eq "desc_rptt";
        
        if ($mode) {
            return fail_clear("desc_rptt invalid entries (expected none)") unless @{$entries} == 0;
        } else {
            return fail_clear("desc_rptt has unexpected number of entries (".scalar(@$entries).") $msg") unless @{$entries} == 1;
            return fail_clear("desc_rptt invalid arguments") unless $args =~ /^Anonymous ARI/;
            return fail_clear("desc_rptt invalid entries") unless @$entries[0] eq $args."= [num_tbl_tpls, num_rules]";
        }
        
        # Verify dump
        my $dump = @{$reports->{reports}}[1];
        return fail_clear("rptts has bad name $msg") unless $dump->{name} eq "rptts";
        return fail_clear("rptts has bad type $msg") unless $dump->{type} eq "tblt";
        my $rows = $dump->{table}->{rows};

        my $found = 0;
        foreach my $row (@$rows) {
            $found = 1 if @$row[0] =~ /^Anonymous ARI/;
        }
        if (!$mode) {
            return fail_clear("Defined Report Entry not found") unless $found;
        } else {
            return fail_clear("Defined report entry found after deletion") if $found;
        }
        
        # Verify get_r1
        my $r1 = @{$reports->{reports}}[2];
        $entries = $r1->{entries};
        if ($mode) {
            return fail_clear("R1 had unexpected number of entries") unless scalar(keys %{$entries}) == 0;
        } else {
            return fail_clear("R1 had unexpected number of entries") unless scalar(keys %{$entries}) == 2;
        }

        return 1;
    };

    # Add a report template (no response expected)
    $mgr->send_ari($agent, $cbor->{"add_rptt"}) || return fail_clear("add_rptt failed"); 

    # Verify
    return -1 if $verify_added->("in initial check") != 1;

    # Restart Agent and repeat Verification
    $mgr->clear_reports($agent);
    $agent->restart();
    return -1 if $verify_added->("after agent restart") != 1;

    # Restart Mgr and repeat Verification
    restart_mgr() || return -1;
    return -1 if $verify_added->("after mgr restart") != 1;

    say "About to delete reports"; my $tmp = <STDIN> if $test_prompt; # Debug Aide
    
    # Delete report
    $mgr->send_ari($agent, $cbor->{"delete_r1"});

    # Repeat Verification
    $mgr->clear_reports($agent);
    return -1 if $verify_added->("after deletion", 1) != 1;

    # Reboot Agent and repeat verification
    $mgr->clear_reports($agent);
    $agent->restart();
    return -1 if $verify_added->("after deletion & agent restart", 1) != 1;

    # Reboot Mgr and repeat verification
    restart_mgr() || return -1;
    return -1 if $verify_added->("after deletion & mgr restart", 1) != 1;

    return 1;
}

sub variable_simple_ops_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3; # TODO: Get from opts
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};

    # Get number of variables prior to definition as baseline for simple verification
    $mgr->send_ari($agent, $cbor->{"list_vars"}) || return fail_clear("list_vars failed");
    my $reports = $mgr->wait_reports($agent, 1, undef, "json");
    return fail_clear("ERROR: Failed to query initial list_vars state") if (!defined($reports));
    my $rpt = @{$reports->{reports}}[0];
    my $table = $rpt->{table};
    my $row = $table->{rows};
    my $init_num_vars = scalar(@$row);
    $mgr->clear_reports($agent);
    
    # Define V1 as 2+2
    $mgr->send_ari($agent, $cbor->{"define_v1"}) || return fail_clear("define_v1 failed");
    
    my $verify_v1 = sub {
        my $msg = shift;
        my $is_delete = shift;
        
        # list_vars and verify V1 is listed
        $mgr->send_ari($agent, $cbor->{"list_vars"}) || return fail_clear("list_vars failed");
        
        # report_v1 and verify it has value UINT 4
        $mgr->send_ari($agent, $cbor->{"report_v1"}) || return fail_clear("report_v1 failed");

        # Get Reports
        my $reports = $mgr->wait_reports($agent, 2, undef, "json");
        return fail_clear("$msg: Failed to find expected number of reports") if (!defined($reports));

        # Verify List
        $rpt = @{$reports->{reports}}[0];
        $table = $rpt->{table};
        $row = $table->{rows};
        if ($is_delete) {
            return fail_clear("$msg: Failed to delete variable (it still exists)") if scalar(@$row) != $init_num_vars;
        } else {
            return fail_clear("$msg: Failed to add variable (not found in list)") if scalar(@$row) != $init_num_vars+1;
        }

        # Verify report value of UINT4
        my $r1 = @{$reports->{reports}}[1];
        my $entries = $r1->{entries};
        if ($is_delete) {
            return fail_clear("$msg: Report shows variable not deleted") unless $r1->{num_entries} == 0;
        } else {
            return fail_clear("$msg: Report entries not an array of size 1") if (scalar(@{$entries}) != 1);
            return fail_clear("$msg: Reported variable value is not 4") if (@{$entries}[0] != 4);
        }

        if ($test_prompt) {
            say "verify_v1 complete ($msg). Press enter to proceed";
            my $tmp = <STDIN>;
        }

        # Clear reports for the next verification step
        $mgr->clear_reports($agent);
        return 1;
    };

    return -1 if $verify_v1->("in initial check") != 1;
    $agent->restart(); # Restart agent
    return -1 if $verify_v1->("after agent restart") != 1;

    # delete_v1
    $mgr->send_ari($agent, $cbor->{"delete_v1"}) || return fail_clear("delete_v1 failed");
    
    return -1 if $verify_v1->("verify deletion", 1) != 1;
    $agent->restart(); # Restart agent
    return -1 if $verify_v1->("verify deletion after agent restart", 1) != 1;
    return 1;
}

sub complex_variables_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3; # TODO: Get from opts
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};

    # Get number of variables prior to definition as baseline for simple verification
    $mgr->send_ari($agent, $cbor->{"list_vars"}) || return fail_clear("list_vars failed");
    my $reports = $mgr->wait_reports($agent, 1, undef, "json");
    return fail_clear("ERROR: Failed to query initial list_vars state") if (!defined($reports));
    my $rpt = @{$reports->{reports}}[0];
    my $table = $rpt->{table};
    my $row = $table->{rows};
    my $init_num_vars = scalar(@$row);
    $mgr->clear_reports($agent);
    
    # Define V2 as 4
    $mgr->send_ari($agent, $cbor->{"define_v2"}) || return fail_clear("define_v2 failed");
    # Define V3=V2+1
    $mgr->send_ari($agent, $cbor->{"define_v3"}) || return fail_clear("define_v3 failed");
    # Define V4 = V3
    $mgr->send_ari($agent, $cbor->{"define_v4"}) || return fail_clear("define_v4 failed");

    # Define R1
    $mgr->send_ari($agent, $cbor->{"define_r1"}) || return fail_clear("define_r1 failed");
    
    # Generate Report R1 and verify values (nominally 4,EXPR,5)
    my $verify_vars = sub {
        my $msg = shift;
        my $expect_v2 = shift;
        my $expect_v4 = shift;

        # list_vars and verify V2,3 and 4 are listed
        $mgr->send_ari($agent, $cbor->{"list_vars"}) || return fail_clear("list_vars failed");

        # Generate report R1
        $mgr->send_ari($agent, $cbor->{"generate_r1"}) || return fail_clear("generate_r1 failed");

        # Get Reports
        my $reports = $mgr->wait_reports($agent, 2, undef, "json");
        return fail_clear("ERROR: Failed to find expected number of reports $msg") if (!defined($reports));

        # Verify List
        $rpt = @{$reports->{reports}}[0];
        $table = $rpt->{table};
        $row = $table->{rows};
        return fail_clear("Failed to add variable") if scalar(@$row) != $init_num_vars+3;

        # # Verify report values
        my $r1 = @{$reports->{reports}}[1];
        my $entries = $r1->{entries};
        return fail_clear("Report has an unexpected number of keys") if scalar(keys %{$entries}) != 3;
        return fail_clear("v2 $entries->{'Entry 0'} != $expect_v2") if $entries->{'Entry 0'} != $expect_v2;
        return fail_clear("v3 is not an expr") unless $entries->{'Entry 1'} =~ /^EXPR/;
        return fail_clear("v4 $entries->{'Entry 2'} != $expect_v4") if $entries->{'Entry 2'} != $expect_v4;

        # Clear reports for the next verification step
        $mgr->clear_reports($agent);
        return 1;
        
    };

    # Note: We are only verifying that second var is an EXPR, rule is implicitly validated through V4
    return -1 if $verify_vars->("Verify initial values", 4,5) != 1;
    
    # Set V2 = V4
    $mgr->send_ari($agent, $cbor->{"store_v2v4"}) || return fail_clear("store_v2v4 failed");
    
    # Set V4 = expr_eval(v3)
    $mgr->send_ari($agent, $cbor->{"store_v4v3"}) || return fail_clear("store_v4v3 failed");
 
    # Generate R1 and verify values are now 5,EXPR,6
    return -1 if $verify_vars->("Verify updated values", 5,6) != 1;
}

sub macros_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3; # TODO: Get from opts
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};

    # Baseline: List Known Macros
    $mgr->send_ari($agent, $cbor->{"list"}) || return fail_clear("list macros failed");
    my $reports = $mgr->wait_reports($agent, 1, undef, "json");
    return fail_clear("ERROR: Failed to query initial list_vars state") if (!defined($reports));
    my $rpt = @{$reports->{reports}}[0];
    my $table = $rpt->{table};
    my $row = $table->{rows};
    my $init_num_macros = scalar(@$row);
    $mgr->clear_reports($agent);

    # Create Macro
    $mgr->send_ari($agent, $cbor->{"create"}) || return fail_clear("create macro failed");

    my $verify_macro = sub {
        my $msg = shift;
        my $is_delete = shift;

        # Describe Macro
        $mgr->send_ari($agent, $cbor->{"describe"}) || return fail_clear("create macro failed");

        # List Macros
        $mgr->send_ari($agent, $cbor->{"list"}) || return fail_clear("list macros failed");

        # Get requested reports
        my $reports = $mgr->wait_reports($agent, 2, undef, "json");
        return fail_clear("$msg: Failed to find expected number of reports $msg") if (!defined($reports));

        # Validate Description
        my $r1 = @{$reports->{reports}}[0];
        my $entries = $r1->{entries};
        if ($is_delete) {
            return fail_clear("$msg: Report has an unexpected number of keys") if scalar(@{$entries}) != 0;
        } else {
            return fail_clear("$msg: Report has an unexpected number of keys") if scalar(@{$entries}) != 1;
            # Note: This step may need to be changed if JSON output is improved.  This is only a quick sanity check for now.
            return fail_clear("$msg: Macro description doesn't match expected") unless @{$entries}[0] =~ /Anonymous ARI.*gen_rpts.*reset_counts.*gen_rpts/;
        }

        # Validate Listing
        $rpt = @{$reports->{reports}}[1];
        $table = $rpt->{table};
        $row = $table->{rows};
        if ($is_delete) {
            return fail_clear("$msg: Failed to delete macro") if scalar(@$row) != $init_num_macros;
        } else {
            return fail_clear("$msg: Failed to add macro") if scalar(@$row) != $init_num_macros+1;
        }

        # Clear reports for the next verification step
        $mgr->clear_reports($agent);
        return 1;
    };

    # Verify
    return -1 if $verify_macro->("Initial verification") != 1;

    # Reboot agent and verify macro still exists
    $agent->restart();
    return -1 if $verify_macro->("After agent restart") != 1;

    # Delete Macro
    $mgr->send_ari($agent, $cbor->{"delete"}) || return fail_clear("delete macro failed");

    # Verify Deletion
    return -1 if $verify_macro->("Verify deletion",1) != 1;
    
    # Reboot Agent and verify macro does not come back
    $agent->restart();
    return -1 if $verify_macro->("Verify deletion after agent restart", 1) != 1;

    return 1;

}

sub tbr_base_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3; # TODO: Get from opts
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};
    my $num_failures = 0;

    # Create the TBR
    $mgr->send_ari($agent, $cbor) || return fail_clear("creating tbr failed");

    # Verify receipt of 5 reports 5 seconds apart (+/- 1s)
    # Use wait reports, but track actual time. Log errors, but don't abort until completion to ensure rule is completed.
    for(my $i = 0; $i < 5; $i++) {
        my $start_time = time;
        my $reports = $mgr->wait_reports($agent, $i+1, 10, "json");
        my $delta_time = time - $start_time;
        if (!defined($reports)) {
            $num_failures++;
            say RED( ($i+1)."th report failed to arrive within expected interval");
        } elsif ($delta_time < 4 || $delta_time > 6) {
                $num_failures++;
                say RED( ($i+1)."th report took $delta_time seconds to arrive; Expected 5s intervals");
        } else {
            say "Report $i received in $delta_time seconds";
        }
    }

    if($num_failures > 0) {
        return -1;
    } else {
        return 1;
    }

}
sub tbr_mod_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3; # TODO: Get from opts
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};

    # Baseline: List Known Rules
    $mgr->send_ari($agent, $cbor->{"list"}) || return fail_clear("list macros failed");
    my $reports = $mgr->wait_reports($agent, 1, undef, "json");
    return fail_clear("ERROR: Failed to query initial list_vars state") if (!defined($reports));
    my $rpt = @{$reports->{reports}}[0];
    my $table = $rpt->{table};
    my $row = $table->{rows};
    my $init_num_rules = scalar(@$row);
    $mgr->clear_reports($agent);
    
    # Create the TBR
    $mgr->send_ari($agent, $cbor->{"define"}) || return fail_clear("define tbr failed");

    my $verify_tbr = sub {
        my $msg = shift;
        my $is_delete = shift;

        # List TBRs
        $mgr->send_ari($agent, $cbor->{"list"}) || return fail_clear("list macros failed");

        # Describe TBR2
        $mgr->send_ari($agent, $cbor->{"describe"}) || return fail_clear("create rule failed");

        # Get requested reports
        my $reports = $mgr->wait_reports($agent, 2, undef, "json");
        return fail_clear("$msg: Failed to find expected number of reports $msg") if (!defined($reports));
        
        # Validate List
        $rpt = @{$reports->{reports}}[0];
        $table = $rpt->{table};
        $row = $table->{rows};
        if ($is_delete) {
            return fail_clear("$msg: Failed to delete rule") if scalar(@$row) != $init_num_rules;
        } else {
            return fail_clear("$msg: Failed to add rule") if scalar(@$row) != $init_num_rules+1;
        }
        
        # Validate description matches definition
        my $r1 = @{$reports->{reports}}[1];
        my $entries = $r1->{entries};
        if ($is_delete) {
            return fail_clear("$msg: Report has an unexpected number of keys") if scalar(@{$entries}) != 0;
        } else {
            return fail_clear("$msg: Report has an unexpected number of keys") if scalar(@{$entries}) != 1;
            # Note: This step may need to be changed if JSON output is improved.  This is only a quick sanity check for now.
            return fail_clear("$msg: Macro description doesn't match expected") unless @{$entries}[0] =~ /^TBR: ID=Anonymous ARI: 0x[0-9a-f]+, S=0, P=30, C=100, A=gen_rpts/;
        }

        if ($test_prompt) {
            say "$msg: Verification complete, about to clear reports";
            my $tmp = <STDIN>;
        }
        
        # Clear reports for the next verification step
        $mgr->clear_reports($agent);
        return 1;
    };

    return -1 unless $verify_tbr->("Verify TBR Creation") == 1;

    # Delete
    $mgr->send_ari($agent, $cbor->{"delete"}) || return fail_clear("delete rule failed");

    # Verify Deletion
    return -1 unless $verify_tbr->("Verify TBR Creation", 1) == 1;

    return 1;
    
}

sub gen_var_report_test
{
    my $idx = shift; # Test number for logging purposes
    my $opts = shift;
    my $agent = $agent3;
    my $cbor = ($use_old_cbor) ? $opts->{cbor_old} : $opts->{cbor};

    ## Baseline: Get count of rules, macros, and variables
    $mgr->send_ari($agent, $cbor->{"list_macros"}) || return fail_clear("list_macros failed");
    $mgr->send_ari($agent, $cbor->{"list_rules"}) || return fail_clear("list_rules failed");

    my $reports = $mgr->wait_reports($agent, 2, undef, "json");
    return fail_clear("ERROR: Failed to find expected number of reports in baseline count collection") if (!defined($reports));
    
    my $base_macro_cnt = get_report_row_count(@{$reports->{reports}}[0]);
    my $base_rules_cnt = get_report_row_count(@{$reports->{reports}}[1]);
    $mgr->clear_reports($agent);
    
    ## Define initial variables/macros
    # Define Variable V5
    $mgr->send_ari($agent, $cbor->{"define_v5"}) || return fail_clear("define_v5 failed");

    # Define Macro M1 to generate an agent FULL REPORT and reset V5=0
    $mgr->send_ari($agent, $cbor->{"define_m1"}) || return fail_clear("define_m1 failed");

    # Step 1.9: Define SRL S1 to run every time V5 >= 2 up to 3 times. 
    #------------------------------------------------------------------------------
    # A1 ARI = 0xa801410101
    # Start = 0
    # Expr = [V5, 2, >=]
    # MaxEval = 1000
    # Count = 3
    # Action = [M1]
    $mgr->send_ari($agent, $cbor->{"define_srl"}) || return fail_clear("define_sr1 failed");

    ## Validate defined macros/rules/variables
    
    # Retrieve + Verify value V5 is 0
    $mgr->send_ari($agent, $cbor->{"retrieve"}) || return fail_clear("retrieve failed");

    # List Macros + Verify
    $mgr->send_ari($agent, $cbor->{"list_macros"}) || return fail_clear("list_macros failed");

    # Describe M1 + Verify
    $mgr->send_ari($agent, $cbor->{"describe_m1"}) || return fail_clear("describe_m1 failed");

    # List Rules + Verify
    $mgr->send_ari($agent, $cbor->{"list_rules"}) || return fail_clear("list_rules failed");

    # Describe SRL
    $mgr->send_ari($agent, $cbor->{"describe_srl"}) || return fail_clear("describe_sr1 failed");

    # Retrieve & verify above 5 reports
    $reports = $mgr->wait_reports($agent, 5, undef, "json");
    return fail_clear("ERROR: Failed to find expected number of reports to validate initial definitions") if (!defined($reports));

    # Verify V5=0
    my $r1 = @{$reports->{reports}}[0];
    my $entries = $r1->{entries};
    return fail_clear("Report entries not an array of size 1") if (scalar(@{$entries}) != 1);
    return fail_clear("Reported variable value is not 0") if (@{$entries}[0] != 0);

    # Verify number of macros
    my $cnt = get_report_row_count(@{$reports->{reports}}[1]);
    return fail_clear("Unexpected number of macros defined") if $base_macro_cnt+1 != $cnt;

    # Verify M1 description
    $r1 = @{$reports->{reports}}[2];
    $entries = $r1->{entries};
    return fail_clear("Report has an unexpected number of keys") if scalar(@{$entries}) != 1;
    return fail_clear("Macro description doesn't match expected") unless @{$entries}[0] =~ /Anonymous ARI.*gen_rpts.*store_var.*EXPR/;

    # Verify Rules Count
    $cnt = get_report_row_count(@{$reports->{reports}}[3]);
    return fail_clear("Unexpected number of rules defined") if $base_rules_cnt+1 != $cnt;

    # Verify SRL Description
    $r1 = @{$reports->{reports}}[4];
    $entries = $r1->{entries};
    return fail_clear("Report has an unexpected number of keys") if scalar(@{$entries}) != 1;
    return fail_clear("Macro description doesn't match expected") unless @{$entries}[0] =~ /^SBR.*E=EXPR.*greaterEqual/;

    if ($test_prompt) {
        say "Initial validation complete, about to clear reports and proceed to next stage";
        my $tmp = <STDIN>;
    }

    # Cleanup for next step
    $mgr->clear_reports($agent);
    
    ## Time Based Rule Definition and Validation

    # Step 1.14: Set TBR T1 to run every 20 seconds 6 times that will
    # run the command: V5 = V5 + 1 which is: STOR(V5, {(UINT), V5 1 +})
    #------------------------------------------------------------------------------
    # T5 ARI = 0xab01410501
    # T5 Start = 0
    # T5 Period = 20
    # T5 Count = 6
    $mgr->send_ari($agent, $cbor->{"define_tbr"}) || return fail_clear("define_tbr failed");
    $mgr->send_ari($agent, $cbor->{"describe_tbr"}) || return fail_clear("describe_tbr failed");
    $mgr->send_ari($agent, $cbor->{"list_rules"}) || return fail_clear("list_rules failed");

    # Retrieve & verify above report
    $reports = $mgr->wait_reports($agent, 2, undef, "json");
    return fail_clear("ERROR: Failed to find expected number of reports to describe tbr") if (!defined($reports));

    # Validate
    $r1 = @{$reports->{reports}}[0];
    $entries = $r1->{entries};
    return fail_clear("Report has an unexpected number of keys") if scalar(@{$entries}) != 1;
    return fail_clear("Macro description doesn't match expected") unless @{$entries}[0] =~ /^TBR.*store_var/;


    $cnt = get_report_row_count(@{$reports->{reports}}[1]);
    return fail_clear("Unexpected number of rules defined") if $base_rules_cnt+2 != $cnt;

    # Wait 170 seconds for rule to run 3 times, 40s apart (approximately)
    say YELLOW "Waiting 170 seconds for rule to execute 3 times";
    sleep(170);
    say YELLOW "Continuing . . . ";

    # Get value of V5 and verify
    $mgr->send_ari($agent, $cbor->{"retrieve"}) || return fail_clear("retrieve failed");
    
    # List known rules and verify S1 and T1 are no longer listed
    $mgr->send_ari($agent, $cbor->{"list_rules"}) || return fail_clear("list_rules failed");

    # Retrieve; 7 reports - desc, list_rules, full_report*3 (via sbr), retrieve, list_rules
    $reports = $mgr->wait_reports($agent, 7, undef, "json");
    return fail_clear("ERROR: Failed to find expected number of reports to validate tbr completion") if (!defined($reports));

    # Verify full_report variables
    # - sent_reports, run_sbr increments for each
    # - run_tbr increments by 2 for each, ending with 6 (if we started at 0)
    $r1 = @{$reports->{reports}}[2]; my $f1 = $r1->{entries};
    $r1 = @{$reports->{reports}}[3]; my $f2 = $r1->{entries};
    $r1 = @{$reports->{reports}}[4]; my $f3 = $r1->{entries};

    return fail_clear("run_tbr value unexpected") unless $f2->{run_tbr}==$f1->{run_tbr}+2 && $f3->{run_tbr}==$f2->{run_tbr}+2 && $f3->{run_tbr} >= 6;
    return fail_clear("run_sbr value unexpected") unless $f2->{run_sbr}==$f1->{run_sbr}+1 && $f3->{run_sbr}==$f2->{run_sbr}+1;

    # Verify V5=0
    $r1 = @{$reports->{reports}}[5];
    $entries = $r1->{entries};
    return fail_clear("Report entries not an array of size 1") if (scalar(@{$entries}) != 1);
    return fail_clear("Reported variable value @{$entries}[0] != ?") if (@{$entries}[0] != 0); #TODO, =3?

    # Verify rules count
    $cnt = get_report_row_count(@{$reports->{reports}}[6]);
    return fail_clear("Unexpected number of rules defined") if $base_rules_cnt != $cnt;
    
    # Delete S1 (verify we can delete an already deleted SBR)
    $mgr->send_ari($agent, $cbor->{"delete_srl"}) || return fail_clear("delete_srl failed");

    # Restart Agent and verify only 1 Var and 1 Macro are restored
    # TODO
    
    return 1;
}

# Agent Object
#  (Note: Global variables will be inherited, but functions must use namespace prefix)
{
    package Agent;
    use Term::ANSIColor qw(:constants);
    local $Term::ANSIColor::AUTORESET = 1;
    
    sub new
    {
        my $class = shift;
        my $eid;
        my $rundir; # Directory to run from
        my $logfile;

        if (scalar(@_) == 1) {
            $eid = shift;
        } else {
            my %opts = @_;
            die "eid is required parameter for Agent->new" unless defined($opts{eid});
            $eid = $opts{eid};
            $rundir = $opts{rundir} if defined($opts{rundir});
        }
        
        $rundir = main::getcwd() unless defined($rundir);
        $logfile = File::Spec->catfile($log_dir, $eid."_0.log") unless defined($logfile);
        
        my $rtv = {
            eid => $eid,
            process => undef,
            dir => $rundir,
           };

        # Rename existing logfile if it exists
        rename($logfile, $logfile.".bak") if (-e $logfile);
            
        # Touch logfile (so we can attach to it before agent starts)
        system("touch $logfile");

        # Begin Expect on "tail -f" of log file
        #  NOTE: We are expecting on Managers log of agent activity, not the agent directly
        #  This avoids potential issues of stdout vs stderr, logfile redirection, and thread clobbering
        $rtv->{expect} = $td->start_expect("tail", "-f", $logfile);
        
        say "Agent Object Created, eid = $eid, dir = $rundir"; # DEBUG
        return bless $rtv;

    }
    sub start
    {
        my $self = shift;
        # TODO: Check if already running
        
        my $eid = $self->{eid};
        my $pwd = main::getcwd();

        say "Agent Starting ...., eid = $eid, dir = $self->{dir}"; # DEBUG
        
        chdir($self->{dir}) || die "Error: Can't enter agent start dir $self->{dir}: $!";

        $self->{process} = $td->start_cmd("nm_agent", $eid, $mgr_eid);
        
        chdir($pwd);
        return $self->{process};
    }
    sub stop
    {
        my $obj = shift;
        $td->stop_cmd($obj->{process});
    }
    sub restart
    {
        my $obj = shift;
        my $eid = $obj->{eid};
        $obj->stop();

        # To be safe, wait for agent to complete shutdown
        sleep(2); # Note: 1s is sufficient for most systems, but some (ie: VMs) take longer

        # Restart agent
        return $obj->start();

        # And wait for it to restart
        sleep(1);
    }
    sub expect
    {
        my $obj = shift;

        # Note: We reversed the order of what and limit vs expect to allow specifying a default time
        # If multiple what's are passed, it should be $agent->expect("str1", $limit, $str2,...), or call directly
        my $what = shift;  # What to wait for
        my $limit = shift // $time_wait_finish;  # Time limit to wait

        my $exp = $obj->{expect};

        $exp->expect(
            $limit,
            $what,
            @_ # Allow additional parameters to pass through to expect
           );
        return $exp->match(); # undef on failure, matched text otherwise
    
    }
    sub expect_clear
    {
        my $obj = shift;

        # Clear Cache from Agent to prepare for next listen case
        $obj->{expect}->clear_accum();
    }

} # End Agent Package

# Mgr Object
{
    package Manager;
    use Term::ANSIColor qw(:constants);
    local $Term::ANSIColor::AUTORESET = 1;

    sub new
    {
        my $class = shift;
        my $eid;
        my $rundir; # Directory to run from

        my %obj = (
            eid => undef,
            process => undef,
            dir => undef,
            mode => "rest"
           );
        
        if (scalar(@_) == 1) {
            $obj{eid} = shift;
        } else {
            # Merge input parameters with defaults
            %obj = (%obj, @_);
        }
        if (!defined($obj{dir})) {
            $obj{dir} = main::getcwd();
        }

        # Validate Arguments
        die "eid is required parameter for Manager->new" unless defined($obj{eid});
        

        return bless \%obj;
    }
    sub start
    {
        my $self = shift;
        # TODO: Check if already running
        my $cwd = main::getcwd();
        chdir($self->{dir}) || die "Can't enter Manager directory $self->{dir}: $!";

        # TODO: If screen mode, add argument to run automator interface

        my @args = (
            "-lRT", # Enable file logging for RX and TX CBOR
            "-D$log_dir", # and specify log file directory
            "-L0", # and specify no limit to entries per file
            "-jJ", # and log to file in JSON format as well
            "-A", # Start in Automator mode
           );
        if ($self->{db}) {
            push(@args, ("--sql-user", $self->{dbuser})) if $self->{dbuser};
            push(@args, ("--sql-pass", $self->{dbpass})) if $self->{dbpass};
            push(@args, ("--sql-host", $self->{dbhost})) if $self->{dbhost};
            push(@args, ("--sql-db", $self->{db})) if $self->{db};
        }

        # EID is last parameter
        push(@args, $self->{eid} );

        $self->{process} = $td->start_cmd("nm_mgr",
                                          join(' ', @args) # TODO: Clean this up
                                         );

        chdir($cwd);
        return $self->{process};
    }
    sub stop
    {
        my $self = shift;
        $td->stop_cmd($self->{process});
    }

    # Return undef if not alive. Some 'defined' value otherwise (do not depend on it's value).
    sub is_alive
    {
        my $self = shift;

        # Is a process running?
        return 0 if !defined($self->{process});

        if ($self->{mode} eq "expect") {
            # EXPECT Mode: Check that we get a prompt when sending newline
            return $self->expect_cmd(1, "\n", "#-NM->");
        } else {
            # REST Mode: Query agents. If we get a response, we are alive
            return $self->get_agents();
        }
    }
    sub get_agents
    {
        my $self = shift;
        if ($self->{mode} eq "expect") {
            my $raw = $self->expect_cmd(1, "L", [qr/^Agents: (.*)?/]);
            if ($raw) {
                $raw =~ s/^Agents: //;
                my @agents = [];
                @agents = split(',', $raw) if $raw;
                return {"agents" => \@agents};
            } else {
                return $raw;
            }
        } else {
            return $self->rest_cmd("GET", "/nm/api/agents");
        }
    }
    sub register_agent
    {
        my $self = shift;
        my $agent = shift;
        my $eid = (ref($agent) eq "") ? $agent : $agent->{eid};
        
        die "Not implemented for this configuration" if $self->{mode} ne "rest";

        return $self->rest_cmd("POST", "nm/api/agents", $eid);
    }
    sub deregister_agent {
        my $eid = shift;
        # TODO
        die "deregister_agent() TODO";
    }
    sub send_ari {
        my $self = shift;
        my $agent = shift;
        my $cbor = shift;
        my $eid = (ref($agent) eq "") ? $agent : $agent->{eid};
        return $self->rest_cmd("PUT","/nm/api/agents/eid/$eid/hex", $cbor );
    }
    sub get_reports {
        my $self = shift;
        my $agent = shift;
        my $format = shift // "hex";
        my $eid = (ref($agent) eq "") ? $agent : $agent->{eid};
        return $self->rest_cmd("GET", "/nm/api/agents/eid/$eid/reports/$format");
    }
    sub wait_reports {
        my $self = shift;
        my $agent = shift;
        my $expected_cnt = shift;
        my $wait_limit = shift // 5;
        my $format = shift // "hex";
        my $eid = (ref($agent) eq "") ? $agent : $agent->{eid};
        my $last_cnt = -1;
        
        # Loop up to $wait_limit times.  If limit is 0, we will still check once
        for(my $i = 0; $i < $wait_limit || $i == 0; $i++) {
            my $data = $self->get_reports($eid,$format);
            return undef if ref($data) ne "HASH"; # Failure if we can't retrieve reports
            
            # Success if expected number of reports have been seen
            my $reports = $data->{reports};
            $last_cnt = scalar(@$reports);
            if ( $last_cnt == $expected_cnt) {
                #say GREEN "$expected_cnt reports received after $i seconds";
                return $data;
            } elsif ($last_cnt > $expected_cnt) {
                #say RED "Saw $last_cnt reports, but only expected $expected_cnt after $i seconds";
                return undef;
            }
            sleep(1);
        }
        say RED "Failed to receive expected number of reports (rcv=$last_cnt != expected=$expected_cnt) within $wait_limit seconds";
        return undef;

    }
    sub clear_reports {
        my $self = shift;
        my $agent = shift;
        my $eid = (ref($agent) eq "") ? $agent : $agent->{eid};
        return $self->rest_cmd("PUT","/nm/api/agents/eid/$eid/clear_reports");
    }

    # TODO: Replace by_idx with by_name
    sub clear_reports_by_idx {
        my $self = shift;
        my $idx = shift;
        return $self->rest_cmd("PUT","/nm/api/agents/idx/$idx/clear_reports");
    }
    sub send_ari_by_idx {
        my $self = shift;
        my $idx = shift;
        my $cbor = shift;
        return $self->rest_cmd("PUT","/nm/api/agents/idx/$idx/hex", $cbor );
    }
    sub get_reports_by_idx {
        my $self = shift;
        my $idx = shift;
        my $format = shift // "hex";
        return $self->rest_cmd("GET", "/nm/api/agents/idx/$idx/reports/$format");
    }

    # REST Mode Query
    sub rest_cmd
    {
        my $self = shift;
        my $method = shift;
        my $uri = shift;
        my $data = shift;
        
        # TODO: Move REST::Client setup & util functions into this package
        return main::do_rest_query($method,$uri,$data);
    }

    # Expect on nm_mgr UI STDIN/STDOUT using AUTOMATOR UI Mode
    #   Note: We will always append a newline to $cmd. If it's a duplicate, it will do no harm
    sub expect_cmd
    {
        my $self = shift;
        my $limit = shift // $time_wait_finish;
        my $cmd = shift;
        # Remaining arguments are passed to expect
        my $exp = $self->{process};

        # Clear Cache
        $exp->clear_accum();

        # Send Command
        $exp->send($cmd."\n");

        # And Expect
        $exp->expect(1, @_);

        # Returning the match (or undef if there was no match)
        return $exp->match();
    }
        
}
